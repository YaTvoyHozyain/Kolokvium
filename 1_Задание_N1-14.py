# N-1
# Сравнение натуральных чисел: 2 - если первое больше второго,
# 0 - если равно, иначе 1
def COM_NN_D(A, B):
    # находим первый ненулевой элемент в первом числе
    i = 0
    while A[i] == 0 and i != len(A):
        i += 1
    # если количество пройденных элементов равно длине массива,
    # то число - ноль
    if i == len(A):
        A1 = [0]
        len1 = 1
    else:
        # начиная с этого элемента заносим все оставшиеся цифры в новый массив А1,
        # где len1 - длина нового массива
        len1 = len(A) - i
        A1 = A[i:]

    # аналогично работаем со вторым числом
    i = 0
    while B[i] == 0 and i != len(B):
        i += 1
    if i == len(B):
        B1 = [0]
        len2 = 1
    else:
        len2 = len(B) - i
        B1 = B[i:]

    # сравниваем длину чисел, которое длиннее - больше
    if len1 > len2:
        return 2
    elif len2 > len1:
        return 1
    # если длины равны
    else:
        i = 0
        # находим номер несовпадающего элемента массивов
        while i != len1 and A1[i] == B1[i]:
            i += 1
        # если такого числа не нашлось, и количество пройденных
        # элементов равно длине массива, то они совпадают
        if i == len1:
            return 0
        else:
            # если несовпадающий элемент первого массива больше,
            # значит первое число больше, иначе - второе
            if A1[i] > B1[i]:
                return 2
            else:
                return 1
# N- 3
# k - количество разрядов, a - массив цифр числа
def ADD_1N_N(k, a):
    a.reversed(a)
    if a[0] < 9:
        # Если последняя цифра числа < 9, то добавляем единицу
        a[0] += 1
    else:
        i = 0
        while (a[i] == 9):
            # Если последняя цифра числа равна 9, то, пока разряды не перестанут
            # быть равными 9, заменяем на 0
            a[i] = 0
            i += 1
            # Если преобразования были осуществлены со всеми разрядами,
            # то добавляем новый разряд
            if i == len(a):
                a.append(0)
                k += 1
            # К первому разряду, не равному 9, добавляем единицу
        a[i] += 1
    a.reverse()
    a = int(''.join(map(str, a)))
    return k, a

# N- 5
# Вычитание из первого большего натурального числа
# второго меньшего или равного
def SUB_NN_N(A, B):
    # если второе число больше, меняем A и B местами
    if COM_NN_D(A, B) == 1:
        temp = A
        A = B
        B = temp
    # если длины чисел не равны, то добавляем нули в начало второго числа
    if len(A) != len(B):
        B.reverse()
        for i in range(len(A) - len(B)):
            B.append(0)
        B.reverse()
    # вычитание
    for i in range(len(B) - 1, -1, -1):
        if A[i] >= B[i]:
            A[i] -= B[i]
        else:
            A[i] = A[i] + 10 - B[i]
            k = i - 1
            while A[k] == 0:
                A[k] = 9
                k -= 1
            A[k] -= 1
    # убираем лишние нули в начале
    i = 0
    while A[i] == 0 and i != len(A) - 1:
        i += 1
    if i == len(A):
        A = [0]
    else:
        A = A[i:]

    return A

# N-11
def DIV_NN_N(a, k, b, n):
    # k - количество разрядов, a - массив цифр числа
    # n - количество разрядов, b - массив цифр числа
    m = DIV_NN_Dk(a, b)
    div = [0] * m[1]
    num = 0
    # Пусть a >= b
    # Тогда, если на вход задаются числа, не удовлетворяющие этому словию,
    # значения меняются местами
    if (k < n) or (k == n and a[k-1] < b[n-1]):
        a, b = b, a
        k, n = n, k
    # Частное от деления a на b
    while (COM_NN_D(a, k, b, n) == 2) or (COM_NN_D(a, k, b, n) == 0):
        c = DIV_NN_Dk(a, k, b, n)
        mul = MUL_NN_N(b, n, c[0], c[1])
        a = SUB_NDN_N(a, k, mul[0], mul[1])
        a = a[0]
        div = ADD_NN_N(div, c[0])
        num += 1
    return num, div[0]

# N-12
def MOD_NN_N(a,k,b,n):
    # k - количество разрядов, a - массив цифр числа
    # n - количество разрядов, b - массив цифр числа
    # Пусть a >= b
    # Тогда, если на вход задаются числа, не удовлетворяющие этому словию,
    # значения меняются местами
    if (k < n) or (k == n and a[k - 1] < b[n - 1]):
        a, b = b, a
        k, n = n, k
    c = DIV_NN_N(a, k, b, n)
    mul = MUL_NN_N(n, b, c[1], c[0])
    mod = SUB_NDN_N(a, k, mul[0], mul[1])
    return mod
