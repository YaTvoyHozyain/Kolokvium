# P-1: Грицкевич
# сложение многочленов
# вход: степень и перевернутый массив коэф-тов первого многочлена, степень и массив коэф-тов второго многчлена
# выход: степень, перевернутый массив коэффов
def ADD_PP_P(m1, C1, m2, C2):
    if COM_NN_D(m1, m2) == 1:  # степень первого полинома должна быть больше второй
        m1, m2 = m2, m1
        C1, C2 = C2, C1
    C = [0] * ADD_1N_N(m1)  # длина массива коэффициентов соответствует степени большего полинома, увеличенной на 1
    m = m1  # степень рез-рующего полинома равна степени большего многочлена
    for i in range(len(C2)):  # задействуются все коэффициенты меньшего полинома
        C[i] = ADD_QQ_Q(C1[i], C2[i])  # сложение коэффициентов
    if COM_NN_D(len(C2), len(C1)) != 0:  # если остались нетронутые коэффициенты в большем полиноме
        C[len(C2):] = C1[len(C2):]
    return m, C

    
# P-2: Черникова
# вычитание многочленов
# дано: многочлены - старш. ст. m1, m2 и перевернутые массивы рац. коэф-в C1, C2
# использовать:
# Q-6 SUB_QQ_Q вычитание дробей
def SUB_PP_P(m1, C1, m2, C2):
    C1, C2 = C1[::-1], C2[::-1]
    # степень 1го многочл. больше ст. 2го
    if (m1 > m2):
        # слева направо переносим коэф-ты 1го многочл., тк из них вычитаются нулевые коэф-ты 2го
        for i in range(m1 - 1, m2 - 1, -1):
            Cres.append(C1[i])
        # затем из оставшихся коэф-в 1го многочл. вычитаем коэф-ты 2го
        for i in range(m2 - 1, -1, -1):
            Cres.append(SUB_QQ_Q(C1[i], C2[i]))
    # степень 1го многочл. меньше ст. 2го
    elif (m1 < m2):
        # слева направо переносим коэф-ты 2го многочл. с минусом, тк они вычитаются из нулевых коэф-в 1го
        for i in range(m2 - 1, m1 - 1, -1):
            # делаем список,кот. можно изменять
            С2list[i] = list(С2[i])
            # берем числ-ль дробного коэф-та, если дробь это (num, denom) и
            # меняем знак у числителя, если num = (b,n,A)
            if С2list[i][0][0] == 0:
                С2list[i][0][0] = 1
            else:
                С2list[i][0][0] = 0
            С2[i] = (С2list[i])
        # затем из коэф-в 1го многочл. вычитаем оставшиеся коэф-ты 2го
        for i in range(m1 - 1, -1, -1):
            Cres.append(SUB_QQ_Q(C1[i][0], C1[i][1], C2[i][0], C2[i][0]))
    mres = SUB_NN_N(len(Cres), 1)
    return mres, Cres[::-1]

    
# P-3: Черникова
# умножение многочлена на рациональное число
# дано: многочлен - старш. ст. m1 и перевернутый массив рац. коэф-в C1; рац. число q
# использовать:
# Q-7 MUL_QQ_Q умножение дробей
def MUL_PQ_P(m1, C1, q):
    Cres = []
    for i in range(len(C1)):
        Cres.append(MUL_QQ_Q(C1[i], q))
    return m1, Cres[::-1]


# P-4 Морик
# Умножение многочлена на x^k
# m – степень многочлена, перевернутый массив C коэффициентов, k - степень переменной, на которую умножается
def MUL_Pxk_P(m, C, k):
    C = [0] * k + C  # в начало добавляется столько нулей, насколько увеличивается в степень
    return ADD_NN_N(m, k), C



# P-5 Прейгель
# старший коэффициент многочлена
def LED_P_Q(m, C):
    for i in range(len(C) - 1, -1, -1):
        if C[i]:
            return C[i]  # возвращаем первый с конца (т.к. массив перевернутый) ненулевой коэффициент
    return 0  # если ненулевых коэффов нет, возвращаем 0


# P-6 Морик
# Степень многочлена
# массив C коэффициентов
def DEG_P_N(C):
    return len(C) - 1  # количество коэффициентов, за исключением свободного члена, по сути и является степенью полинома



# P-7 Грицкевич
# Вынесение из многочлена НОК знаменателей коэффициентов и НОД числителей 
# Чтобы найти НОД чисел, сначала нужно поэтапно находить НОД 2 чисел от первого 
# коэффициента к последнему
# Чтобы найти НОК чисел, делаем то же самое
def FAC_P_Q(m, arr):
    nok = []
    nod = []
    i = 0
    # Переделываем в положительное натуральное
    for i in range(0, m + 1):
        if POZ_Z_D(arr[i].A) == 1:
            arr[i].A = ABS_Z_N(arr[i].A)
        else:
            arr[i].A = TRANS_Z_N(arr[i].A)
    # Если степень = 0
    if m == 0:
        nod = arr[i].A
        nok = arr[i].B
    else:
        # Ищем НОК и НОД первых 2 чисел
        for i in range(0, m + 1):
            if i == 0:
                nod = GCF_NN_N(arr[i].A, arr[i + 1].A)
                nok = LCM_NN_N(arr[i].B, arr[i + 1].B)
            else:
                # Ищем НОК и НОД последующих
                if i < m:
                    nod = GCF_NN_N(nod, arr[i + 1].A)
                    nok = LCM_NN_N(nok, arr[i + 1].B)
    return TRANS_N_Z(nok), TRANS_N_Z(nod)

   
    
# P-8 Морик
# Умножение многочленов (пока с ссылками такими)
# C1 - перевернутые коэффициенты первого многочлена, m1 - старшая степень первого многочлена,
# C2 - перевернутые коэффициенты второго многочлена, m2 - старшая степень второго многочлена
# надо использовать: MUL_PQ_P - умножение многочлена на рациональное число, MUL_Pxk_P - умножение многочлена на x ^ k
# ADD_PP_P - Сложение многочленов

def MUL_PP_P(m1, C1, m2, C2):

    C1, C2 = C1[::-1], C2[::-1]  # переворачиваю для удобства работы
    if COM_NN_D(m1, m2) == 2:  # первый многочлен для удобства должен быть больше степенью, чем второй
        m1, m2 = m2, m1
        C1, C2 = C2, C1

    m, _ = MUL_Pxk_P(m2, C2, m1)[0]  # степень рез-рующего полинома - рез-т умножения 1го полинома на степ. x 2го
    C = [0 for i in range(ADD_1N_N(m))]  # количество коэфф-тов будет соответствовать степени полученного многочлена + 1

    for i in range(len(С1)):  # чтобы второй полином перемножился на все коэффициенты первого полинома
        m0, C0 = MUL_PQ_P(C1[i], C2, m2)  # умножаем второй полином на i-тый коэффициент первого полинома
        k = 0
        m, C = ADD_PP_P(C0, m0, C, i)  # к рез-рующему полиному добавляется полученный в кач-ве домножения,
        # старшей степени соответствует номер нынешней итерации

    return m, C[::-1]  # возвращается старшая степень полученного многочлена и перевернутый массив его коэффициентов


# P-9 Симанович
# Частное от деления многочлена на многочлен при делении с остатком
# C1 - перевернутый массив коэффициентов первого многочлена (делимое),
# deg1 - степень первого многочлена (делимое),
# C2 - перевернутый массив коэффициентов второго многочлена (делитель)
# deg2 - степень второго многочлена (делитель)
# Надо использовать:
# DIV_QQ_Q - Деление дробей
# DEG_P_N - Степень многочлена
# MUL_Pxk_P - Умножение многочлена на x^k
# SUB_PP_P - Вычитание многочленов
# ADD_PP_P - Сложение многочленов
def DIV_PP_P(deg1, C1, deg2, C2):
    C3 = copy.deepcopy(C2)  # *Копирование, чтобы потом вернуть C2 изначальные значение, так как функция MUL_Pxk_P
    # изменяет массив-параметр, а не возвращает новый массив
    # Если степень делимого меньше степени делителя, то целое от такого деление = 0
    if deg1 < deg2:
        return [0]
    else:
        div = [0 for _ in range(deg1 - deg2 + 1)]  # Создаем массив коэффициентов целого необходимой длины
    # Пока степень делимого больше или равна степени делителя будет выполняться:
    while deg1 >= deg2:
        # Домножаем делитель до степени делителя и сохраняем это промежуточное значение
        m, res = MUL_Pxk_P(deg2, C2, deg1 - deg2)
        # Возвращаем C2 изначальные значения
        C2 = C3
        # Число, на которое необходимо домножить делитель, чтобы убрать старшую степень
        num = DIV_QQ_Q(LED_P_Q(deg1, C1), LED_P_Q(deg2, C2))
        # Домножаем промежуточное значение на частное от деления старших членов текущего делимого и делителя
        m, res = MUL_PQ_P(DEG_P_N(res), res, num)
        # Вычитаем из делимого результат, степень делимого уменьшится
        deg1, C1 = SUB_PP_P(deg1, C1, m, res)
        # Удаление незначащих нулей (необходимость зависит от реализации функции SUB_PP_P)
        while C1[0] == 0 and len(C1) != 1:
            C1.pop(0)
        # Добавляем коэффициент в результирующий массив
        div[deg1 - deg2] = num
        deg1, deg2 = DEG_P_N(C1), DEG_P_N(C2)
    # Возвращает массив коэффициентов целого (первый коэффициент - младший)
    return DEG_P_N(div), div


# P-10 Симанович
# Остаток от деления многочлена на многочлен при делении с остатком
# C1 - перевернутый массив коэффициентов первого многочлена (делимое), m1 - степень этого многочлена,
# C2 - перевернутый массив коэффициентов второго многочлена (делитель), m2 - степень этого многочлена
# Надо использовать:
# DIV_PP_P - Частное от деления многочлена на многочлен при делении с остатком
# MUL_PP_P - Умножение многочленов
# SUB_PP_P - Вычитание многочленов

def MOD_PP_P(m1, C1, m2, C2):
    deg, div = DIV_PP_P(C1, C2)  # Находим частное от деления двух многочленов
    m, res = SUB_PP_P(m1, C1, *MUL_PP_P(deg, div, m2, C2))  # Вычитаем из первого исходного многочлена
    # произведение частного на второй
    return m, res


# P-11 Морик
# НОД многочленов
# C1 - перевернутый массив коэффициентов первого многочлена, m1 - старшая степень первого многочлена,
# C2 - перевернутый массив коэффициентов второго многочлена, m2 - старшая степень второго многочлена
# надо использовать: DEG_P_N - степень многочлена,
# MOD_PP_P - Остаток от деления многочлена на многочлен при делении с остатком
def null_polynomial(m, C):  # проверка на то, является ли полином нулевым
    for i in range(len(C)):
        if C[i] != 0:
            return False
    return True

def GCF_PP_P(m1, C1, m2, C2):

    deg1, deg2 = m1, m2  # чтобы не портить изначальные данные
    coef1, coef2 = C1[::-1], C2[::-1]

    if null_polynomial(m1, C1) or null_polynomial(m2, C2):
        return 0  # т.е. один из полиномов нулевой, следовательно, нет НОД

    if COM_NN_D(m1, m2) == 1:  # первый многочлен-делимое должен быть больше степенью, чем второй многочлен-делитель
        deg1, deg2 = deg2, deg1
        coef1, coef2 = coef2, coef1

    while MOD_PP_P(deg1, coef1, deg2, coef2) != 0:  # пока остаток от деления многочленов не станет равен нулю
        deg, coef = MOD_PP_P(deg1, coef1, deg2, coef2)  # коэффы остатка
        deg1, coef1, deg2, coef2 = deg2, coef2, deg, coef  # 1 полином - делимое, 2 полином - остаток, теперь делитель

    # довели до момента, когда делитель остался нужный для получения НОД (это deg2 и coef2)

    coef = coef1[:len(coef2)]  # часть от делимого, равная по длине делителю, т.к. работаем элементами столбика
    for i in range(len(coef1)):
        rM, CM = MOD_PP_P(DEG_P_N(coef), coef, deg2, coef2)  # остаток от coef при делении на меньший степенью полином
        if CM[-1] != 0:  # если этот остаток не равен 0. Чтобы сохранился НОД, идущий перед нулевым остатком
            deg, coef = rM, CM
            if len(coef2) + i < len(coef1):  # перестраховка, чтобы не было ошибок с индексацией
                coef.append(coef1[len(coef2) + i])  # добавляем следующий коэффициент из нашего изначального делимого
        else:
            break
    return DEG_P_N(coef), coef


# P-12 Прейгель
# производная многочлена
def DER_P_P(m, C):
    C = C[::-1]
    # приведение коэффициентов к виду (b,n,A[])
    for x in range(m):
        C_new = []
        if str(C[x])[0] == "-":
            b1 = 1
        else:
            b1 = 0
        d = 0
        for i in str(C[x]):
            if i == "." and b1 != 1:
                n = d
            elif i == "." and b1 == 1:
                n = d - 1
            elif i != "-":
                C_new.append(int(i))
            d += 1
        n1 = len(C_new)
        M = []
        X = []
        for i in str(m):
            M.append(int(i))
        for i in str(x):
            X.append(int(i))
        A = SUB_NN_N(M, X)
        b2 = 0
        n2 = len(A)
        b3, n3, C[x] = MUL_ZZ_Z(b1, n1, C_new, b2, n2, A)  # умножение коэффициентов на соответствующую им степень
        if n and n > 0:
            C[x] = C[x][:n + (n3 - n1)] + ["."] + C[x][n + (n3 - n1):]
        if b1 == 1:
            C[x] = ["-"] + C[x]
        if C[x][len(C[x]) - 1] == 0 and C[x][len(C[x]) - 2] == ".":
            C[x].pop(len(C[x]) - 2)
            C[x].pop(len(C[x]) - 1)
        str1 = ""
        for i in range(len(C[x])):
            str1 += str(C[x][i])
        for i in C[x]:
            if i == ".":
                n = -2
        if n == -2:
            C[x] = float(str1)
        else:
            C[x] = int(str1)
        n = - 1
    m = m - 1  # понижение степени многочлена
    C.pop(len(C) - 1)  # выброс последнего коэффициента - свободного члена
    return m, C[::-1]


# P-13 Симанович
# Преобразование многочлена — кратные корни в простые
# C1 - перевернутый массив коэффициентов многочлена, который необходимо сократить, m1 - его степень.
# Надо использовать:
# DIV_PP_P - Частное от деления многочлена на многочлен при делении с остатком
# DER_P_P - Производная многочлена
# GCF_PP_P - НОД многочленов
def NMR_P_P(m1, C1):
    # Простые корни многочлена не являются корнями его производной
    # А кратный корень многочлена является корнем его производной на единицу меньшей кратности
    # Значит, НОД многочлена и его производной равен произведению кратных корней многочлена на единицу меньшей кратности
    # Находим производную многочлена
    C1 = C1[::-1]
    m, C = DER_P_P(C1)
    # Находим НОД многочлена и производной
    GCD = GCF_PP_P(m1, C1, m, C)
    # Делим многочлен на НОД
    res = DIV_PP_P(m1, C1, GCD)
    # Возвращает массив коэффициентов (первый коэффициент - младший)
    return DEG_P_N(res), res[::-1]
