# P-2: вычитание многочленов
# вход: многочлен1, многочлен2::: степень многочлена, массив рац. коэффициентов
# выход: кортеж (степень, (рац.коэф-ты))
# здесь подразумевается, что массив рац. коэф-в имеет вид q1[i]=[((b1,n1,[A1]),(n2,[A2])), ((b21,n21,[A21]),(n22,[A22])), ... ]
def SUB_PP_P(m1,q1,m2,q2):
    err = 0
    # проверка знаменателей входящих рац. дробей на 0
    for i in range(m1):
        if q1[i][1][1] == 0:
            print("Rational rate denominator must be different 0!")
            err = 1
            break
    for i in range(m2):
        if q2[i][1][1] == 0:
            print("Rational rate denominator must be different 0!")
            err1 = 0
            break
    # заполнить массив с меньшим кол-вом элементов нулевыми коэф-ми
    if err != 0:
        if m1 > m2:
            for i in range((m1-m2)):
                q2.insert(0, ((0, 1, [0]), (0, 1, [0])) )
        elif m2 > m1:
            for i in range((m2-m1)):
                q1.insert(0, ((0, 1, [0]), (0, 1, [0])) )
        # вычесть рац. коэф-ты (исп. Q-6)
        for i in range(max(m1, m2)):
            q[i] = SUB_QQ_Q(q1[i], q2[i])
            q.insert(0, q[i])
        q = (len(q), q)
        return q
    
# P-4 - Умножение многочлена на x^k
# m – степень многочлена, массив C коэффициентов, k - степень переменной, на которую умножается
def MUL_Pxk_P(m, C, k):
    C.extend([0] * k)
    return ADD_NN_N(m, k), C

# P - 5 - старший коэффициент многочлена
def LED_P_Q(m, C):
    # возврат первого коэффициента из массива коэффициентов - он и является старшим
    return C[0]

# P-6 - Степень многочлена
# массив C коэффициентов
def DEG_P_N(C):
    return len(C) - 1  # количество коэффициентов, за исключением свободного члена, по сути и является степенью полинома

# Q-7: умножение дробей
# вход: дробь1, дробь2::: знак,ст.поз-я,мас-в цифр целого числ-ля,  ст.поз-я,мас-в цифр нат. знам-ля
# выход: дробь::: кортеж ((цел.числ-ль),(нат.знам-ль))
def MUL_QQ_Q(b1, n1, A1, n2, A2, b3, n3, A3, n4, A4):
    if A2 != [0] and A4 != [0]:
        if A1 != [0] and A3 != [0]:
            # ИНАЧЕ умножение цел. числителей (исп.Z-8)
            Q1 = MUL_ZZ_Z(b1, n1, A1, b3, n3, A3,)
            # умножение натур. знаменателей (исп.N-8)
            Q2 = MUL_NN_N(n2,A2,n4,A4)
            # сокращение рац. дроби (исп.Q-1)
            Q = RED_Q_Q(Q1[0], Q1[1], Q1[2], Q2[0], Q2[1])
        else:
            Q = (0, 1, [0])
        return Q
    # ЕСЛИ хотя бы один знам-ль 0, вывод 'Can't divide by zero.'
    # ИНАЧЕ ЕСЛИ хотя бы один числ-ль 0, вывод 0
    else:
        print("Can't divide by zero.")

# P-8 - Умножение многочленов(пока с сылками такими)
# C1 - коэффициенты первого многочлена, m1 - старшая степень первого многочлена,
# C2 - коэффициенты второго многочлена, m2 - старшая степень второго многочлена
# надо использовать: MUL_PQ_P - умножение многочлена на рациональное число, MUL_Pxk_P - умножение многочлена на x ^ k
def MUL_PP_P(m1, C1, m2, C2):
    if COM_NN_D(m1, m2) == 2:  # первый многочлен для удобства должен быть меньше степенью, чем второй
        m1, m2 = m2, m1
        C1, C2 = C2, C1

    m = MUL_Pxk_P(m2, C2, m1)[0]  # степень рез-рующего полинома - рез-т умножения 1-го полинома на x ^ 2-го полинома
    C = [0] * ADD_1N_N(m)  # количество коэффициентов будет соответствовать степени полученного многочлена + 1

    for i in range(len(С1)):  # чтобы второй полином перемножился на все коэффициенты первого полинома
        C0, m0 = MUL_PQ_P(C1[i], C2, m2)  # умножаем второй полином на i-тый коэффициент первого полинома
        k = 0
        for j in range(i, i + len(C0)):  # цикл, который обновляет коэффициенты для рез-рующего полинома
            C[j] = ADD_NN_N(C[j], C0[k])  # к уже полученному коэффициенту степени + новый коэффициент после умножения
            k = ADD_1N_N(k)  # счетчик индексов в массиве новых коэффов

    return m, C  # возвращается массив полученных коэффициентов и старшая степень полученного сногочлена

# P-11 - НОД многочленов
# C1 - коэффициенты первого многочлена, m1 - старшая степень первого многочлена,
# C2 - коэффициенты второго многочлена, m2 - старшая степень второго многочлена
# надо использовать DEG_P_N - степень многочлена,
# MOD_PP_P - Остаток от деления многочлена на многочлен при делении с остатком

def GCF_PP_P(m1, C1, m2, C2):
    deg1, deg2 = m1, m2  # чтобы не портить изначальные данные
    coef1, coef2 = C1, C2

    if COM_NN_D(m1, m2) == 1:  # первый многочлен-делимое должен быть больше степенью, чем второй многочлен-делитель
        deg1, deg2 = deg2, deg1
        coef1, coef2 = coef2, coef1

    while MOD_PP_P(deg1, coef1, deg2, coef2) != 0:  # пока остаток от деления многочленов не станет равен нулю
        coef = MOD_PP_P(deg1, coef1, deg2, coef2)  # коэффы остатка
        deg = DEG_P_N(coef)  # степень получившегося остатка (в MOD_PP_P не передает?)
        deg1, coef1, deg2, coef2 = deg2, coef2, deg, coef  # 1 полином - делимое, 2 полином - остаток, теперь делитель

    # довели до момента, когда делитель остался нужный для получения НОД (это deg2 и coef2)

    coef = coef1[:len(coef2)]  # часть от делимого, равная по длине делителю, т.к. работаем элементами столбика
    for i in range(len(coef1)):
        r = MOD_PP_P(DEG_P_N(coef), coef, deg2, coef2)  # остаток от той части делимого при делении на делитель
        if r != 0:  # если этот остаток не равен 0. Чтобы сохранился НОД, идущий перед нулевым остатком
            coef = r
            if len(coef2) + i < len(coef1):  # перестраховка, чтобы не было ошибок с индексацией
                coef.append(coef1[len(coef2) + i])  # добавляем следующий коэффициент из нашего изначального делимого
        else:
            break
    return coef

# P - 12 - производная многочлена
def DER_P_P(m, C):
    # умножение коэффициентов на соответсвующую им степень
    for x in range(m):
        C[x] = C[x] * (m - x) #(не знаю, насколько законно можно применять здесь умножение без соответствующей функции, но в задании нет ни одной функции, на которую нужно сослаться)
    m = m - 1 # понижение степени многочлена
    C.pop(len(C) - 1) # выброс последнего коэффициента - свободного члена
    return(m, C)
