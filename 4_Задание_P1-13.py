# P-4 - Умножение многочлена на x^k
# m – степень многочлена, массив C коэффициентов, k - степень переменной, на которую умножается
def MUL_Pxk_P(m, C, k):
    C.extend([0] * k)
    return ADD_NN_N(m, k), C

# P-6 - Степень многочлена
# массив C коэффициентов
def DEG_P_N(C):
    return len(C) - 1  # количество коэффициентов, за исключением свободного члена, по сути и является степенью полинома

# P-8 - Умножение многочленов(пока с сылками такими)
# C1 - коэффициенты первого многочлена, m1 - старшая степень первого многочлена,
# C2 - коэффициенты второго многочлена, m2 - старшая степень второго многочлена
# надо использовать: MUL_PQ_P - умножение многочлена на рациональное число, MUL_Pxk_P - умножение многочлена на x ^ k
def MUL_PP_P(m1, C1, m2, C2):
    if COM_NN_D(m1, m2) == 2:  # первый многочлен для удобства должен быть меньше степенью, чем второй
        m1, m2 = m2, m1
        C1, C2 = C2, C1

    m = MUL_Pxk_P(m2, C2, m1)[0]  # степень рез-рующего полинома - рез-т умножения 1-го полинома на x ^ 2-го полинома
    C = [0] * ADD_1N_N(m)  # количество коэффициентов будет соответствовать степени полученного многочлена + 1

    for i in range(len(С1)):  # чтобы второй полином перемножился на все коэффициенты первого полинома
        C0, m0 = MUL_PQ_P(C1[i], C2, m2)  # умножаем второй полином на i-тый коэффициент первого полинома
        k = 0
        for j in range(i, i + len(C0)):  # цикл, который обновляет коэффициенты для рез-рующего полинома
            C[j] = ADD_NN_N(C[j], C0[k])  # к уже полученному коэффициенту степени + новый коэффициент после умножения
            k = ADD_1N_N(k)  # счетчик индексов в массиве новых коэффов

    return m, C  # возвращается массив полученных коэффициентов и старшая степень полученного сногочлена

# P-11 - НОД многочленов
# C1 - коэффициенты первого многочлена, m1 - старшая степень первого многочлена,
# C2 - коэффициенты второго многочлена, m2 - старшая степень второго многочлена
# надо использовать DEG_P_N - степень многочлена,
# MOD_PP_P - Остаток от деления многочлена на многочлен при делении с остатком

def GCF_PP_P(m1, C1, m2, C2):
    deg1, deg2 = m1, m2  # чтобы не портить изначальные данные
    coef1, coef2 = C1, C2

    if COM_NN_D(m1, m2) == 1:  # первый многочлен-делимое должен быть больше степенью, чем второй многочлен-делитель
        deg1, deg2 = deg2, deg1
        coef1, coef2 = coef2, coef1

    while MOD_PP_P(deg1, coef1, deg2, coef2) != 0:  # пока остаток от деления многочленов не станет равен нулю
        coef = MOD_PP_P(deg1, coef1, deg2, coef2)  # коэффы остатка
        deg = DEG_P_N(coef)  # степень получившегося остатка (в MOD_PP_P не передает?)
        deg1, coef1, deg2, coef2 = deg2, coef2, deg, coef  # 1 полином - делимое, 2 полином - остаток, теперь делитель

    # довели до момента, когда делитель остался нужный для получения НОД (это deg2 и coef2)

    coef = coef1[:len(coef2)]  # часть от делимого, равная по длине делителю, т.к. работаем элементами столбика
    for i in range(len(coef1)):
        r = MOD_PP_P(DEG_P_N(coef), coef, deg2, coef2)  # остаток от той части делимого при делении на делитель
        if r != 0:  # если этот остаток не равен 0. Чтобы сохранился НОД, идущий перед нулевым остатком
            coef = r
            if len(coef2) + i < len(coef1):  # перестраховка, чтобы не было ошибок с индексацией
                coef.append(coef1[len(coef2) + i])  # добавляем следующий коэффициент из нашего изначального делимого
        else:
            break
    return coef
