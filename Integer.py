# Z-1 Селиверстов
# Абсолютная величина числа
# A - массив чисел, b - знак
def ABS_Z_N(A, b):
    # возвращаем число без знака
    return A


# Z-2 Михайлова
# Определение положительности числа
# A - массив чисел, b - знак
def POZ_Z_D(A, b):
    # b = 0 - положительное, 1 - отрицательное
    # если число ноль возвращаем 0
    if A == [0] * len(A):
        return 0
    # если число положительное возвращаем 2
    elif b == 0:
        return 2
    # если число отрицательное возвращаем 1
    else:
        return 1


# Z-3 Махаев
# Умножение целого на -1
# A - массив чисел, b - знак
def MUL_ZM_Z(A, b):
    # меняем знак на противоположный
    if b == 0:
        b = 1
    elif b == 1:
        b = 0
    else:
        print('error Z-3')
    return A, b


# Z-4 Счастливая
# Преобразование натурального в целое
# A - массив чисел, b - знак
def TRANS_N_Z(A):
    # добавляем натуральному числу знак, превращая в целое
    b = 0
    return A, b


# Z-5 Грицкевич
# Преобразование целого неотрицательного числа в натуральное
# A - массив чисел, b - знак
def TRANS_Z_N(A, b):
    # возвращаем число без знака
    return A


# Z-6 Булацкий
# Сложение целых чисел
# A, B - массивы чисел, ka, kb - знаки
# result - результирующий массив, res_k - знак получившегося числа
def ADD_ZZ_Z(A, ka, B, kb):
    # Если оба числа равны нулю (POZ_Z_D - проверка на положительность), то их сумма тоже будет равна 0
    if POZ_Z_D(A, ka) == POZ_Z_D(B, kb) & POZ_Z_D(A, ka) == 0:
        result = [0]
        res_k = 0
    else:
        # если числа одного знака
        if POZ_Z_D(A, ka) == POZ_Z_D(B, kb):
            # Используем функцию сложения натуральных чисел (для этого берем модули чисел)
            result = ADD_NN_N(ABS_Z_N(A, ka), ABS_Z_N(B, kb))
            # превращаем натуральное в целое
            result, res_k = TRANS_N_Z(result)
            # Если оба числа отрицательные (POZ_Z_D - проверка на положительность)
            if POZ_Z_D(A, ka) == 1:
                # Домножаем результат на -1
                result, res_k = MUL_ZM_Z(result, res_k)
        # Если у чисел разные знаки
        else:
            # Сравниваем два числа по модулю
            raz = COM_NN_D(ABS_Z_N(A, ka), ABS_Z_N(B, kb))
            # Если а > b то
            if raz == 2:
                # Вычитаем из первого большего натурального числа второе меньшее
                result = SUB_NN_N(ABS_Z_N(A, ka), ABS_Z_N(B, kb))
                # превращаем натуральное в целое
                result, res_k = TRANS_N_Z(result)
                # Если первое число отрицательное
                if POZ_Z_D(A, ka) == 1:
                    # Домножаем результат на -1
                    result, res_k = MUL_ZM_Z(result, res_k)
            # Если а < b то
            else:
                # Вычитаем из второго большего натурального числа первое меньшее
                result = SUB_NN_N(ABS_Z_N(A, ka), ABS_Z_N(B, kb))
                # превращаем натуральное в целое
                result, res_k = TRANS_N_Z(result)
                # Если второе число отрицательное
                if POZ_Z_D(B, kb) == 1:
                    # Домножаем результат на -1
                    result, res_k = MUL_ZM_Z(result, res_k)
    return result, res_k


# Z-7 Горевская
# Вычитание целых чисел
# A, B - массивы чисел, b1, b2 - знаки
def SUB_ZZ_Z (A, b1, B, b2):
    # Сделаем резервные массивы
    Ai = copy.deepcopy(A)
    Bi = copy.deepcopy(B)
    bi1 = b1
    bi2 = b2
    # Сравним числа с нулём
    # POZ_Z_D - сравнение с нулём
    # 2 => a > 0
    # 1 => a < 0
    # 0 => a == 0
    pozA = POZ_Z_D(A, b1)
    pozB = POZ_Z_D(B, b2)
    # Сравним числа друг с другом
    # COM_NN_D - сравнение нат. чисел
    # 2 => a > b
    # 1 => a < b
    # 0 => a == b
    com = COM_NN_D(A, B)
    # Рассмотрим разные случаи:
    # 1) Результат сравнения: a > 0   b > 0
    if(pozA == 2 and pozB == 2):
        if com == 0:
        # a == b -> результат вычитания 0
            return [0], 0
        # a < b || a > b
        # Функция вычитания расставит числа в нужном порядке
        if (com == 2) or (com == 1):
            SUB_NN_N(Ai, Bi)
            # a > b - проводим
            # обычное вычитание, иначе - домножаем
            # результат на (-1) функцией MUL_ZM_Z
            if com == 1:
                MUL_ZM_Z(Ai, bi1)
            return Ai, bi1
    # 2) Результат сравнения: a < 0   b < 0
    if(pozA == 1 and pozB == 1):
        # a == b -> - результат вычитания 0
        if com == 0:
            return [0], 0
        if (com == 2) or (com == 1):
            # Проводим вычитание
            SUB_NN_N(Ai, Bi)
            # Если a > b - разность отрицательна
            # -> домножаем на (-1) MUL_ZM_Z
            if com == 2:
                MUL_ZM_Z(Ai, bi1)
            return Ai, bi1
    # 3) Результат сравнения: a > 0   b < 0
    if(pozA == 2 and pozB == 1):
        # a == |b| -> - результат вычитания 0
        if com == 0:
            return [0], 0
        # Если 1 число > 0, а 2 < 0,
        # тогда вычитание замещается сложением:
        ADD_NN_N(Ai, Bi)
        return Bi, 0
    # 4) Результат сравнения: a < 0   b > 0
    if(pozA == 1 and pozB == 2):
        # Если 1 число < 0, а 2 > 0,
        # тогда вычитание замещается сложением
        # с последующим домножением на (-1):
        ADD_NN_N(Ai, Bi)
        MUL_ZM_Z(Bi, bi2)
        return Bi, bi2
    # 5) Результат сравнения: a = 0   b > 0
    if(pozA == 0 and pozB == 2):
        MUL_ZM_Z(Bi, bi2)
        return Bi, bi2
    # 6) Результат сравнения: a = 0   b < 0
    if(pozA == 0 and pozB == 1):
        MUL_ZM_Z(B, b2)
        return Bi, bi2
    # 7) Результат сравнения: a > 0   b = 0
    if(pozA == 2 and pozB == 0):
        return Ai, bi1
    # 8) Результат сравнения: a < 0   b = 0
    if(pozA == 1 and pozB == 0):
        return Ai, bi1
    # 9) Результат сравнения: a = 0   b = 0
    else:
        return [0], 0


# Z-8 Прейгель
# умножение целых чисел
# A, B - массивы чисел, b1, b2 - знаки чисел
def MUL_ZZ_Z(A, b1, B, b2):
    # используем функцию проверки на положительность
    # если одно из чисел - 0, то новое число тоже 0, иначе перемножаем модули чисел
    if POZ_Z_D(A, b1) == 0 or POZ_Z_D(B, b2) == 0:
        result = [0]
        # превращаем натуральное в целое
        result, res_b = TRANS_N_Z(result)
    else:
        # воспользуемся функцией умножения натуральных чисел (для этого возьмем их модули)
        result = MUL_NN_N(ABS_Z_N(A, b1), ABS_Z_N(B, b2))
        # превращаем натуральное в целое
        result, res_b = TRANS_N_Z(result)
    # если одно число положительное, а другое отрицательное, то знак "минус"
    if (POZ_Z_D(A, b1) == 2 and POZ_Z_D(B, b2) == 1) or (POZ_Z_D(A, b1) == 1 and POZ_Z_D(B, b2) == 2):
        # используем функцию домнажения на -1
        result, res_b = MUL_ZM_Z(result, res_b)
    return result, res_b


# Z-9 Моисеев
# частное от деления целого на целое
# A, B - массивы чисел, b1, b2 - знаки
def DIV_ZZ_Z(A, b1, B, b2):
    # если числитель ноль
    if POZ_Z_D(A, b1) == 0:
        return [0], 0
    # проверяем равен ли нулю делитель
    if POZ_Z_D(B, b2) != 0:
        # находим частное от деления большего натурального числа на меньшее или
        # равное натуральное с остатком (делитель отличен от нуля), берем числа по модулю
        result = DIV_NN_N(ABS_Z_N(A, b1), ABS_Z_N(B, b2))
        # преобразование натурального в целое
        result, res_b = TRANS_N_Z(result)
        # если оба числа положительные или оба отрицательные, то знак "плюс"
        if (POZ_Z_D(A, b1) == 2 and POZ_Z_D(B, b2) == 2) or (POZ_Z_D(A, b1) == 1 and POZ_Z_D(B, b2) == 1):
            return result, res_b
        # иначе знак "минус"
        else:
            # используем функцию домнажения на -1
            result, res_b = MUL_ZM_Z(result, res_b)
            return result, res_b
    else:
        return "Делитель равен нулю"


# Z-10 Горевская
# остаток от деления целого на целое
# A, B - массивы чисел, b1, b2 - знаки
def MOD_ZZ_Z(A, b1, B, b2):
    # если числитель ноль
    if POZ_Z_D(A, b1) == 0:
        return [0], 0
    if POZ_Z_D(B, b2) != 0:
        # используем функцию нахождения остатка от деления нат. чисел
        # (для этого используем модули целых чисел) res - нат. число
        res = MOD_NN_N(ABS_Z_N(A, b1), ABS_Z_N(B, b2))
        # если знаки чисел равны, то нат. число превращаем в целое
        if b1 == b2:
            return TRANS_N_Z(res)
        # если знаки разные, и числитель - отрицательное
        elif b1 == 1:
            # к результату добавляем единицу и превращаем в целое
            res = TRANS_N_Z(ADD_1N_N(res))
            return res
        # если знаки разные, и знаменатель - отрицательное
        else:
            return TRANS_N_Z(res)
    else:
        return "Делитель равен нулю"
